/*
#[cfg(test)]
pub mod wb_user_expanded;
在 entities/mod.rs文件中增加以上代码可以让改文件IDE有提示 如果不能编译改项目 删除这个文件 或者注释了
*/
pub mod wb_user_expanded {
    //! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.4
    use sea_orm::entity::prelude::*;
    pub struct Model {
        #[sea_orm(primary_key)]
        pub uid: u32,
        pub phone: String,
        pub password: String,
        pub created_time: u32,
        pub updated_time: u32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Model {
        #[inline]
        fn clone(&self) -> Model {
            Model {
                uid: ::core::clone::Clone::clone(&self.uid),
                phone: ::core::clone::Clone::clone(&self.phone),
                password: ::core::clone::Clone::clone(&self.password),
                created_time: ::core::clone::Clone::clone(&self.created_time),
                updated_time: ::core::clone::Clone::clone(&self.updated_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Model {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Model",
                "uid",
                &self.uid,
                "phone",
                &self.phone,
                "password",
                &self.password,
                "created_time",
                &self.created_time,
                "updated_time",
                &&self.updated_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Model {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Model {
        #[inline]
        fn eq(&self, other: &Model) -> bool {
            self.uid == other.uid
                && self.phone == other.phone
                && self.password == other.password
                && self.created_time == other.created_time
                && self.updated_time == other.updated_time
        }
    }
    /// Generated by sea-orm-macros
    pub enum Column {
        /// Generated by sea-orm-macros
        Uid,
        /// Generated by sea-orm-macros
        Phone,
        /// Generated by sea-orm-macros
        Password,
        /// Generated by sea-orm-macros
        CreatedTime,
        /// Generated by sea-orm-macros
        UpdatedTime,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Column {}
    #[automatically_derived]
    impl ::core::clone::Clone for Column {
        #[inline]
        fn clone(&self) -> Column {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Column {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Column::Uid => "Uid",
                    Column::Phone => "Phone",
                    Column::Password => "Password",
                    Column::CreatedTime => "CreatedTime",
                    Column::UpdatedTime => "UpdatedTime",
                },
            )
        }
    }
    ///An iterator over the variants of [Column]
    #[allow(missing_copy_implementations)]
    pub struct ColumnIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl core::fmt::Debug for ColumnIter {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("ColumnIter")
                .field("len", &self.len())
                .finish()
        }
    }
    impl ColumnIter {
        fn get(&self, idx: usize) -> Option<Column> {
            match idx {
                0usize => ::core::option::Option::Some(Column::Uid),
                1usize => ::core::option::Option::Some(Column::Phone),
                2usize => ::core::option::Option::Some(Column::Password),
                3usize => ::core::option::Option::Some(Column::CreatedTime),
                4usize => ::core::option::Option::Some(Column::UpdatedTime),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Column {
        type Iterator = ColumnIter;
        fn iter() -> ColumnIter {
            ColumnIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for ColumnIter {
        type Item = Column;
        fn next(&mut self) -> Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, Option<usize>) {
            let t = if self.idx + self.back_idx >= 5usize {
                0
            } else {
                5usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 5usize {
                self.idx = 5usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                self.get(idx - 1)
            }
        }
    }
    impl ExactSizeIterator for ColumnIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for ColumnIter {
        fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 5usize {
                self.back_idx = 5usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                self.get(5usize - self.back_idx)
            }
        }
    }
    impl Clone for ColumnIter {
        fn clone(&self) -> ColumnIter {
            ColumnIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl Column {
        fn default_as_str(&self) -> &str {
            match self {
                Self::Uid => "uid",
                Self::Phone => "phone",
                Self::Password => "password",
                Self::CreatedTime => "created_time",
                Self::UpdatedTime => "updated_time",
            }
        }
    }
    #[automatically_derived]
    impl std::str::FromStr for Column {
        type Err = sea_orm::ColumnFromStrErr;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            match s {
                "uid" | "uid" => Ok(Column::Uid),
                "phone" | "phone" => Ok(Column::Phone),
                "password" | "password" => Ok(Column::Password),
                "created_time" | "createdTime" => Ok(Column::CreatedTime),
                "updated_time" | "updatedTime" => Ok(Column::UpdatedTime),
                _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for Column {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                .unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Column {
        fn as_str(&self) -> &str {
            self.default_as_str()
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::ColumnTrait for Column {
        type EntityName = Entity;
        fn def(&self) -> sea_orm::prelude::ColumnDef {
            match self {
                Self::Uid => {
                    sea_orm::prelude::ColumnTypeTrait::def(sea_orm::prelude::ColumnType::Unsigned)
                }
                Self::Phone => sea_orm::prelude::ColumnTypeTrait::def(
                    sea_orm::prelude::ColumnType::String(None),
                ),
                Self::Password => sea_orm::prelude::ColumnTypeTrait::def(
                    sea_orm::prelude::ColumnType::String(None),
                ),
                Self::CreatedTime => {
                    sea_orm::prelude::ColumnTypeTrait::def(sea_orm::prelude::ColumnType::Unsigned)
                }
                Self::UpdatedTime => {
                    sea_orm::prelude::ColumnTypeTrait::def(sea_orm::prelude::ColumnType::Unsigned)
                }
            }
        }
        fn select_as(&self, expr: sea_orm::sea_query::Expr) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
            }
        }
        fn save_as(&self, val: sea_orm::sea_query::Expr) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct Entity;
    #[automatically_derived]
    impl ::core::marker::Copy for Entity {}
    #[automatically_derived]
    impl ::core::clone::Clone for Entity {
        #[inline]
        fn clone(&self) -> Entity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Entity {
        #[inline]
        fn default() -> Entity {
            Entity {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Entity {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Entity")
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::EntityTrait for Entity {
        type Model = Model;
        type Column = Column;
        type PrimaryKey = PrimaryKey;
        type Relation = Relation;
    }
    #[automatically_derived]
    impl sea_orm::Iden for Entity {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                .unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Entity {
        fn as_str(&self) -> &str {
            <Self as sea_orm::EntityName>::table_name(self)
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::EntityName for Entity {
        fn schema_name(&self) -> Option<&str> {
            None
        }
        fn table_name(&self) -> &str {
            "wb_user"
        }
        fn comment(&self) -> Option<&str> {
            None
        }
    }
    /// Generated by sea-orm-macros
    pub enum PrimaryKey {
        /// Generated by sea-orm-macros
        Uid,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PrimaryKey {}
    #[automatically_derived]
    impl ::core::clone::Clone for PrimaryKey {
        #[inline]
        fn clone(&self) -> PrimaryKey {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PrimaryKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uid")
        }
    }
    ///An iterator over the variants of [PrimaryKey]
    #[allow(missing_copy_implementations)]
    pub struct PrimaryKeyIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl core::fmt::Debug for PrimaryKeyIter {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("PrimaryKeyIter")
                .field("len", &self.len())
                .finish()
        }
    }
    impl PrimaryKeyIter {
        fn get(&self, idx: usize) -> Option<PrimaryKey> {
            match idx {
                0usize => ::core::option::Option::Some(PrimaryKey::Uid),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
        type Iterator = PrimaryKeyIter;
        fn iter() -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for PrimaryKeyIter {
        type Item = PrimaryKey;
        fn next(&mut self) -> Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, Option<usize>) {
            let t = if self.idx + self.back_idx >= 1usize {
                0
            } else {
                1usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 1usize {
                self.idx = 1usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                self.get(idx - 1)
            }
        }
    }
    impl ExactSizeIterator for PrimaryKeyIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for PrimaryKeyIter {
        fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 1usize {
                self.back_idx = 1usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                self.get(1usize - self.back_idx)
            }
        }
    }
    impl Clone for PrimaryKeyIter {
        fn clone(&self) -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for PrimaryKey {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                .unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for PrimaryKey {
        fn as_str(&self) -> &str {
            match self {
                Self::Uid => "uid",
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
        type Column = Column;
        fn into_column(self) -> Self::Column {
            match self {
                Self::Uid => Self::Column::Uid,
            }
        }
        fn from_column(col: Self::Column) -> Option<Self> {
            match col {
                Self::Column::Uid => Some(Self::Uid),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl PrimaryKeyTrait for PrimaryKey {
        type ValueType = u32;
        fn auto_increment() -> bool {
            true
        }
    }
    #[automatically_derived]
    impl sea_orm::FromQueryResult for Model {
        fn from_query_result(
            row: &sea_orm::QueryResult,
            pre: &str,
        ) -> std::result::Result<Self, sea_orm::DbErr> {
            Ok(Self {
                uid: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Uid,
                        )
                            .into(),
                    )?,
                phone: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Phone,
                        )
                            .into(),
                    )?,
                password: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Password,
                        )
                            .into(),
                    )?,
                created_time: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CreatedTime,
                        )
                            .into(),
                    )?,
                updated_time: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedTime,
                        )
                            .into(),
                    )?,
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::ModelTrait for Model {
        type Entity = Entity;
        fn get(&self, c: <Self::Entity as sea_orm::entity::EntityTrait>::Column) -> sea_orm::Value {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Uid => {
                    self.uid.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Phone => {
                    self.phone.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Password => {
                    self.password.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreatedTime => {
                    self.created_time.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedTime => {
                    self.updated_time.clone().into()
                }
                _ => {
                    ::core::panicking::panic_fmt(format_args!("field does not exist on Model"));
                }
            }
        }
        fn set(
            &mut self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
            v: sea_orm::Value,
        ) {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Uid => {
                    self.uid = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Phone => {
                    self.phone = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Password => {
                    self.password = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreatedTime => {
                    self.created_time = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedTime => {
                    self.updated_time = v.unwrap();
                }
                _ => {
                    ::core::panicking::panic_fmt(format_args!("field does not exist on Model"));
                }
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct ActiveModel {
        /// Generated by sea-orm-macros
        pub uid: sea_orm::ActiveValue<u32>,
        /// Generated by sea-orm-macros
        pub phone: sea_orm::ActiveValue<String>,
        /// Generated by sea-orm-macros
        pub password: sea_orm::ActiveValue<String>,
        /// Generated by sea-orm-macros
        pub created_time: sea_orm::ActiveValue<u32>,
        /// Generated by sea-orm-macros
        pub updated_time: sea_orm::ActiveValue<u32>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ActiveModel {
        #[inline]
        fn clone(&self) -> ActiveModel {
            ActiveModel {
                uid: ::core::clone::Clone::clone(&self.uid),
                phone: ::core::clone::Clone::clone(&self.phone),
                password: ::core::clone::Clone::clone(&self.password),
                created_time: ::core::clone::Clone::clone(&self.created_time),
                updated_time: ::core::clone::Clone::clone(&self.updated_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ActiveModel {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "ActiveModel",
                "uid",
                &self.uid,
                "phone",
                &self.phone,
                "password",
                &self.password,
                "created_time",
                &self.created_time,
                "updated_time",
                &&self.updated_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ActiveModel {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ActiveModel {
        #[inline]
        fn eq(&self, other: &ActiveModel) -> bool {
            self.uid == other.uid
                && self.phone == other.phone
                && self.password == other.password
                && self.created_time == other.created_time
                && self.updated_time == other.updated_time
        }
    }
    #[automatically_derived]
    impl std::default::Default for ActiveModel {
        fn default() -> Self {
            <Self as sea_orm::ActiveModelBehavior>::new()
        }
    }
    #[automatically_derived]
    impl std::convert::From<<Entity as EntityTrait>::Model> for ActiveModel {
        fn from(m: <Entity as EntityTrait>::Model) -> Self {
            Self {
                uid: sea_orm::ActiveValue::unchanged(m.uid),
                phone: sea_orm::ActiveValue::unchanged(m.phone),
                password: sea_orm::ActiveValue::unchanged(m.password),
                created_time: sea_orm::ActiveValue::unchanged(m.created_time),
                updated_time: sea_orm::ActiveValue::unchanged(m.updated_time),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::IntoActiveModel<ActiveModel> for <Entity as EntityTrait>::Model {
        fn into_active_model(self) -> ActiveModel {
            self.into()
        }
    }
    #[automatically_derived]
    impl sea_orm::ActiveModelTrait for ActiveModel {
        type Entity = Entity;
        fn take(
            &mut self,
            c: <Self::Entity as EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as EntityTrait>::Column::Uid => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.uid);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Phone => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.phone);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Password => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.password);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::CreatedTime => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.created_time);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::UpdatedTime => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.updated_time);
                    value.into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::not_set(),
            }
        }
        fn get(
            &self,
            c: <Self::Entity as EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as EntityTrait>::Column::Uid => self.uid.clone().into_wrapped_value(),
                <Self::Entity as EntityTrait>::Column::Phone => {
                    self.phone.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Password => {
                    self.password.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::CreatedTime => {
                    self.created_time.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::UpdatedTime => {
                    self.updated_time.clone().into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::not_set(),
            }
        }
        fn set(&mut self, c: <Self::Entity as EntityTrait>::Column, v: sea_orm::Value) {
            match c {
                <Self::Entity as EntityTrait>::Column::Uid => {
                    self.uid = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Phone => {
                    self.phone = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Password => {
                    self.password = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::CreatedTime => {
                    self.created_time = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::UpdatedTime => {
                    self.updated_time = sea_orm::ActiveValue::set(v.unwrap());
                }
                _ => {
                    ::core::panicking::panic_fmt(format_args!(
                        "This ActiveModel does not have this field"
                    ));
                }
            }
        }
        fn not_set(&mut self, c: <Self::Entity as EntityTrait>::Column) {
            match c {
                <Self::Entity as EntityTrait>::Column::Uid => {
                    self.uid = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Phone => {
                    self.phone = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Password => {
                    self.password = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::CreatedTime => {
                    self.created_time = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::UpdatedTime => {
                    self.updated_time = sea_orm::ActiveValue::not_set();
                }
                _ => {}
            }
        }
        fn is_not_set(&self, c: <Self::Entity as EntityTrait>::Column) -> bool {
            match c {
                <Self::Entity as EntityTrait>::Column::Uid => self.uid.is_not_set(),
                <Self::Entity as EntityTrait>::Column::Phone => self.phone.is_not_set(),
                <Self::Entity as EntityTrait>::Column::Password => self.password.is_not_set(),
                <Self::Entity as EntityTrait>::Column::CreatedTime => {
                    self.created_time.is_not_set()
                }
                <Self::Entity as EntityTrait>::Column::UpdatedTime => {
                    self.updated_time.is_not_set()
                }
                _ => {
                    ::core::panicking::panic_fmt(format_args!(
                        "This ActiveModel does not have this field"
                    ));
                }
            }
        }
        fn default() -> Self {
            Self {
                uid: sea_orm::ActiveValue::not_set(),
                phone: sea_orm::ActiveValue::not_set(),
                password: sea_orm::ActiveValue::not_set(),
                created_time: sea_orm::ActiveValue::not_set(),
                updated_time: sea_orm::ActiveValue::not_set(),
            }
        }
        fn reset(&mut self, c: <Self::Entity as EntityTrait>::Column) {
            match c {
                <Self::Entity as EntityTrait>::Column::Uid => self.uid.reset(),
                <Self::Entity as EntityTrait>::Column::Phone => self.phone.reset(),
                <Self::Entity as EntityTrait>::Column::Password => self.password.reset(),
                <Self::Entity as EntityTrait>::Column::CreatedTime => self.created_time.reset(),
                <Self::Entity as EntityTrait>::Column::UpdatedTime => self.updated_time.reset(),
                _ => {
                    ::core::panicking::panic_fmt(format_args!(
                        "This ActiveModel does not have this field"
                    ));
                }
            }
        }
    }
    #[automatically_derived]
    impl std::convert::TryFrom<ActiveModel> for <Entity as EntityTrait>::Model {
        type Error = sea_orm::DbErr;
        fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
            if match a.uid {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("uid".to_owned()));
            }
            if match a.phone {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("phone".to_owned()));
            }
            if match a.password {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("password".to_owned()));
            }
            if match a.created_time {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("created_time".to_owned()));
            }
            if match a.updated_time {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("updated_time".to_owned()));
            }
            Ok(Self {
                uid: a.uid.into_value().unwrap().unwrap(),
                phone: a.phone.into_value().unwrap().unwrap(),
                password: a.password.into_value().unwrap().unwrap(),
                created_time: a.created_time.into_value().unwrap().unwrap(),
                updated_time: a.updated_time.into_value().unwrap().unwrap(),
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::TryIntoModel<<Entity as EntityTrait>::Model> for ActiveModel {
        fn try_into_model(self) -> Result<<Entity as EntityTrait>::Model, sea_orm::DbErr> {
            self.try_into()
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Model {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    pub enum Relation {}
    #[automatically_derived]
    impl ::core::marker::Copy for Relation {}
    #[automatically_derived]
    impl ::core::clone::Clone for Relation {
        #[inline]
        fn clone(&self) -> Relation {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Relation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {}
        }
    }
    ///An iterator over the variants of [Relation]
    #[allow(missing_copy_implementations)]
    pub struct RelationIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl core::fmt::Debug for RelationIter {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("RelationIter")
                .field("len", &self.len())
                .finish()
        }
    }
    impl RelationIter {
        fn get(&self, idx: usize) -> Option<Relation> {
            match idx {
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Relation {
        type Iterator = RelationIter;
        fn iter() -> RelationIter {
            RelationIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for RelationIter {
        type Item = Relation;
        fn next(&mut self) -> Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, Option<usize>) {
            let t = if self.idx + self.back_idx >= 0usize {
                0
            } else {
                0usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 0usize {
                self.idx = 0usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                self.get(idx - 1)
            }
        }
    }
    impl ExactSizeIterator for RelationIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for RelationIter {
        fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 0usize {
                self.back_idx = 0usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                self.get(0usize - self.back_idx)
            }
        }
    }
    impl Clone for RelationIter {
        fn clone(&self) -> RelationIter {
            RelationIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::RelationTrait for Relation {
        fn def(&self) -> sea_orm::entity::RelationDef {
            match self {
                _ => {
                    ::core::panicking::panic_fmt(format_args!("No RelationDef for Relation"));
                }
            }
        }
    }
    impl ActiveModelBehavior for ActiveModel {}
}
